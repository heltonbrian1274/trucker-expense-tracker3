// ======================
// --- Polyfills ---
// ======================
if (!window.requestIdleCallback) {
    window.requestIdleCallback = function(callback) {
        return setTimeout(() => callback({ timeRemaining: () => 16 }), 0);
    };
}

// ======================
// --- Global Variables & Constants ---
// ======================
const expenseCategories=[{id:'fuel',name:'Fuel',icon:'‚õΩ'},{id:'maintenance',name:'Maintenance & Repairs',icon:'üîß'},{id:'meals',name:'Meals',icon:'üçΩÔ∏è'},{id:'lodging',name:'Lodging',icon:'üè®'},{id:'tolls',name:'Tolls & Parking',icon:'üõ£Ô∏è'},{id:'permits',name:'Permits & Licenses',icon:'üìã'},{id:'insurance',name:'Insurance',icon:'üõ°Ô∏è'},{id:'phone',name:'Phone & Communication',icon:'üì±'},{id:'supplies',name:'Supplies & Equipment',icon:'üì¶'},{id:'training',name:'Training & Education',icon:'üìö'},{id:'medical',name:'Medical & DOT Exams',icon:'üè•'},{id:'office',name:'Office Expenses',icon:'üè¢'},{id:'bank',name:'Bank & Financial Fees',icon:'üè¶'},{id:'legal',name:'Legal & Professional',icon:'‚öñÔ∏è'},{id:'other',name:'Other Business Expenses',icon:'üíº'}];

// State Variables - iOS-safe initialization
let expenses = [];
let isDarkMode = false;
let currentSection = 'today';
let isSubscribed = false;
let trialStartDate = null;
let isTrialExpired = false;

// iOS Modal State Management - NEW
let iosModalState = {
    isModalOpen: false,
    originalBodyStyles: {},
    originalScrollPosition: 0,
    preventModalShow: false
};

// Initialize state with iOS-safe localStorage access
try {
    const expensesData = safeLocalStorageGet('truckerExpenses');
    expenses = expensesData ? JSON.parse(expensesData) : [];

    isDarkMode = safeLocalStorageGet('darkMode') === 'true';
    isSubscribed = safeLocalStorageGet('isSubscribed') === 'true';

    trialStartDate = safeLocalStorageGet('trialStartDate');
    if (!trialStartDate) {
        trialStartDate = Date.now().toString();
        safeLocalStorageSet('trialStartDate', trialStartDate);
    }
} catch (error) {
    console.warn('State initialization error:', error);
    // Use defaults if localStorage fails
    expenses = [];
    isDarkMode = false;
    isSubscribed = false;
    trialStartDate = Date.now().toString();
}

// ======================
// --- iOS/Safari Compatibility Helpers ---
// ======================
function isIOSDevice() {
    // Enhanced iOS detection
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    
    // Direct iOS device detection
    if (/iPad|iPhone|iPod/.test(userAgent)) {
        return true;
    }
    
    // iPad Pro in desktop mode detection
    if (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) {
        return true;
    }
    
    // iOS Safari specific detection
    if (/Safari/.test(userAgent) && /Mobile/.test(userAgent) && !/Chrome/.test(userAgent)) {
        return true;
    }
    
    // Check for iOS-specific features
    if (window.DeviceMotionEvent !== undefined && window.DeviceOrientationEvent !== undefined) {
        return /Mobile|Tablet/.test(userAgent);
    }
    
    return false;
}

function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}

// Enhanced iOS-safe localStorage operations
function safeLocalStorageSet(key, value) {
    try {
        // Test if localStorage is available first
        const test = '__localStorage_test__';
        localStorage.setItem(test, 'test');
        localStorage.removeItem(test);
        localStorage.setItem(key, value);
        return true;
    } catch (e) {
        console.warn('localStorage.setItem failed:', e);
        // iOS private browsing or storage quota exceeded
        try {
            // Clear some space and try again
            if (e.name === 'QuotaExceededError') {
                // Clear old data except critical subscription info
                const criticalKeys = ['isSubscribed', 'subscriptionToken', 'hasSeenWelcome'];
                Object.keys(localStorage).forEach(storageKey => {
                    if (!criticalKeys.includes(storageKey)) {
                        try {
                            localStorage.removeItem(storageKey);
                        } catch (cleanupError) {
                            console.warn('Cleanup failed:', cleanupError);
                        }
                    }
                });
                localStorage.setItem(key, value);
                return true;
            }
            
            // Fallback to sessionStorage for iOS private browsing
            sessionStorage.setItem(key, value);
            return true;
        } catch (e2) {
            console.warn('sessionStorage.setItem also failed:', e2);
            // Last resort: use in-memory storage for this session
            if (!window.memoryStorage) window.memoryStorage = {};
            window.memoryStorage[key] = value;
            return false;
        }
    }
}

function safeLocalStorageGet(key) {
    try {
        const value = localStorage.getItem(key);
        if (value !== null) return value;
        
        // Fallback to sessionStorage
        const sessionValue = sessionStorage.getItem(key);
        if (sessionValue !== null) return sessionValue;
        
        // Last resort: check memory storage
        if (window.memoryStorage && window.memoryStorage[key]) {
            return window.memoryStorage[key];
        }
        
        return null;
    } catch (e) {
        console.warn('localStorage/sessionStorage access failed:', e);
        // Try memory storage
        if (window.memoryStorage && window.memoryStorage[key]) {
            return window.memoryStorage[key];
        }
        return null;
    }
}

// ======================
// --- iOS Modal Management Functions - NEW/IMPROVED ---
// ======================

function saveBodyStyles() {
    if (isIOSDevice()) {
        iosModalState.originalBodyStyles = {
            position: document.body.style.position || '',
            top: document.body.style.top || '',
            left: document.body.style.left || '',
            right: document.body.style.right || '',
            width: document.body.style.width || '',
            height: document.body.style.height || '',
            overflow: document.body.style.overflow || '',
            overflowX: document.body.style.overflowX || '',
            overflowY: document.body.style.overflowY || '',
            touchAction: document.body.style.touchAction || '',
            webkitOverflowScrolling: document.body.style.webkitOverflowScrolling || ''
        };
        iosModalState.originalScrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    }
}

function restoreBodyStyles() {
    if (isIOSDevice() && iosModalState.originalBodyStyles) {
        Object.keys(iosModalState.originalBodyStyles).forEach(property => {
            document.body.style[property] = iosModalState.originalBodyStyles[property];
        });
        
        // Restore scroll position
        window.scrollTo(0, iosModalState.originalScrollPosition);
        
        // Clear the saved styles
        iosModalState.originalBodyStyles = {};
        iosModalState.originalScrollPosition = 0;
    }
}

function applyIOSModalStyles(modal) {
    if (!isIOSDevice()) return;
    
    // Save current body styles before making changes
    saveBodyStyles();
    
    // Apply iOS-specific modal container styles
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.width = '100vw';
    modal.style.height = '100vh';
    modal.style.zIndex = '10000';
    modal.style.overflow = 'auto';
    modal.style.webkitOverflowScrolling = 'touch';
    modal.style.touchAction = 'manipulation';
    
    // Apply body styles to prevent background scrolling
    // CRITICAL FIX: Don't use position: fixed on body for iOS
    document.body.style.overflow = 'hidden';
    document.body.style.touchAction = 'none';
    document.body.style.webkitOverflowScrolling = 'touch';
    
    // Set modal state
    iosModalState.isModalOpen = true;
}

function removeIOSModalStyles(modal) {
    if (!isIOSDevice()) return;
    
    // Remove modal-specific styles
    modal.style.position = '';
    modal.style.top = '';
    modal.style.left = '';
    modal.style.right = '';
    modal.style.bottom = '';
    modal.style.width = '';
    modal.style.height = '';
    modal.style.overflow = '';
    modal.style.webkitOverflowScrolling = '';
    modal.style.touchAction = '';
    
    // Restore body styles
    restoreBodyStyles();
    
    // Clear modal state
    iosModalState.isModalOpen = false;
    
    // Force layout recalculation
    modal.offsetHeight;
    document.body.offsetHeight;
    
    // Dispatch resize event to fix any layout issues
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 100);
}

// ======================
// --- DOMContentLoaded & Initialization ---
// ======================
document.addEventListener('DOMContentLoaded', function () {
    // iOS-specific handling
    if (isIOSDevice()) {
        // Prevent zoom on input focus
        document.addEventListener('touchstart', function() {}, {passive: true});

        // Add iOS-specific meta tags if not present
        if (!document.querySelector('meta[name="apple-mobile-web-app-capable"]')) {
            const metaCapable = document.createElement('meta');
            metaCapable.name = 'apple-mobile-web-app-capable';
            metaCapable.content = 'yes';
            document.head.appendChild(metaCapable);
        }
        
        // Add viewport meta tag for iOS if not present
        if (!document.querySelector('meta[name="viewport"]')) {
            const metaViewport = document.createElement('meta');
            metaViewport.name = 'viewport';
            metaViewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            document.head.appendChild(metaViewport);
        }
    }

    // Defer non-critical initialization
    requestIdleCallback(() => {
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js', {
                updateViaCache: 'none' // iOS Safari compatibility
            })
                .then(registration => {
                    console.log('SW registered:', registration);

                    // iOS-specific: Force service worker activation
                    if (isIOSDevice() && registration.waiting) {
                        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                    }
                })
                .catch(error => console.log('SW registration failed:', error));

            // Listen for service worker messages
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'FORCE_HARD_REFRESH') {
                        // iOS requires a hard refresh
                        console.log('Force hard refresh requested by service worker');
                        window.location.reload(true);
                        return;
                    }

                    if (event.data && (event.data.type === 'ALL_CACHE_CLEARED' ||
                                               event.data.type === 'FORCE_REFRESH_UI' ||
                                               event.data.type === 'CACHE_CLEARED')) {
                        console.log('Service worker cache cleared, updating UI');
                        setTimeout(() => {
                            updateTrialCountdownWithAlreadySubscribed();
                            manageSubscriptionButtons();
                        }, 50);
                    }
                });
            }
        }
    });

    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    // Reset trial logic (for URL ?reset=trial)
    if (urlParams.get('reset') === 'trial') {
        try {
            localStorage.clear();
            sessionStorage.clear();
        } catch (e) {
            console.warn('Storage clear failed:', e);
        }
        location.reload();
        return;
    }

    // If there's a token, handle subscription immediately before app initialization
    if (token) {
        safeLocalStorageSet('subscriptionToken', token);
        safeLocalStorageSet('isSubscribed', 'true');
        safeLocalStorageSet('hasSeenWelcome', 'true');
        isSubscribed = true;
        
        // CRITICAL: Prevent modal from showing on iOS during token processing
        if (isIOSDevice()) {
            iosModalState.preventModalShow = true;
        }
        
        // Critical path initialization
        initializeApp();
        
        // Verify token immediately
        verifySubscriptionToken(token);
    } else {
        // Critical path initialization
        initializeApp();

        // Defer subscription checks
        requestIdleCallback(() => {
            checkSubscriptionStatusFromServer();
        });
    }
});

// ======================
// --- App Initialization Logic ---
// ======================
function initializeApp() {
    // Sync global subscription status with iOS-safe localStorage
    isSubscribed = safeLocalStorageGet('isSubscribed') === 'true';

    if (isDarkMode) {
        document.body.classList.add('dark-mode');
        const toggleBtn = document.querySelector('.dark-mode-toggle');
        if (toggleBtn) toggleBtn.textContent = '‚òÄÔ∏è';
    }

    const currentExpenses = JSON.parse(localStorage.getItem('truckerExpenses') || '[]');
    const urlParams = new URLSearchParams(window.location.search);
    const hasToken = urlParams.get('token');

    // Get subscription status using multiple checks for reliability
    const userIsSubscribed = safeLocalStorageGet('isSubscribed') === 'true' || isSubscribed;

    // For iOS: Additional check to prevent modal during token processing
    const isIOSWithTokenProcessing = isIOSDevice() && (hasToken || urlParams.toString().includes('token') || iosModalState.preventModalShow);

    // Initialize core components first (always needed regardless of subscription status)
    populateExpenseGrid();

    // Initialize welcome modal close button with multiple fallbacks
    const closeWelcomeBtn = document.getElementById('closeWelcomeBtn');
    if (closeWelcomeBtn) {
        closeWelcomeBtn.addEventListener('click', closeWelcomeModal);

        // iOS-specific: Add touch event as fallback with proper event handling
        if (isIOSDevice()) {
            closeWelcomeBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                closeWelcomeModal();
            }, { passive: false });
            
            // Additional safety: touchstart event
            closeWelcomeBtn.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            }, { passive: false });
        }
    }

    // Initialize the Already Subscribed feature
    initializeAlreadySubscribedFeature();

    // Initialize enhanced validation system
    initializeEnhancedValidation();

    // Use the enhanced trial countdown function
    updateTrialCountdownWithAlreadySubscribed();

    // Force immediate UI update for subscribed users
    if (localStorage.getItem('isSubscribed') === 'true') {
        // Clear service worker cache first - but only if needed
        if (!window.cacheAlreadyCleared) {
            clearServiceWorkerCache();
            window.cacheAlreadyCleared = true;
        }

        setTimeout(() => {
            updateTrialCountdownWithAlreadySubscribed();
        }, 100);
    }

    // iOS-specific: Force close any existing modals immediately
    if (isIOSDevice()) {
        closeAllModals();
        // Set the flag to prevent welcome modal from ever showing on iOS after subscription
        if (userIsSubscribed || hasToken || isIOSWithTokenProcessing) {
            safeLocalStorageSet('hasSeenWelcome', 'true');
        }
    }

    // Handle welcome modal logic after core initialization
    // Never show welcome modal if:
    // 1. User is subscribed (any method)
    // 2. User has already seen welcome
    // 3. There's a token being processed (especially important for iOS)
    // 4. iOS device with any subscription-related URL params
    // 5. iOS modal prevention flag is set
    if (userIsSubscribed ||
        localStorage.getItem('hasSeenWelcome') ||
        hasToken ||
        isIOSWithTokenProcessing ||
        (isIOSDevice() && iosModalState.preventModalShow)) {
        console.log('üö´ Welcome modal blocked - user subscribed or token processing');
        return; // Early return is now safe since core components are already initialized
    }

    // Only show for truly new, non-subscribed users with no expenses
    // But NEVER on iOS if there are any URL parameters
    if (currentExpenses.length === 0 && (!isIOSDevice() || window.location.search === '')) {
        // Additional iOS safety check
        if (isIOSDevice()) {
            // Check if we're in a potentially problematic state
            const isProblematicState = 
                document.referrer.includes('stripe') ||
                document.referrer.includes('payment') ||
                window.location.href.includes('#') ||
                (performance.navigation && performance.navigation.type === 1); // reload
                
            if (isProblematicState) {
                console.log('üö´ iOS Welcome modal blocked - problematic state detected');
                safeLocalStorageSet('hasSeenWelcome', 'true');
                return;
            }
        }
        
        showWelcomeModal();
    }
    
    updateToggleIcon();
    updateSummary();
    updateInsights();

    const action = urlParams.get('action');
    if (action === 'add-fuel') {
        showSection('today');
        setTimeout(() => toggleExpenseCard('fuel'), 500);
    } else if (action === 'insights') {
        showSection('insights');
    }

    // Debounced search functionality
    const expenseSearch = document.getElementById('expenseSearch');
    let searchTimeout;
    expenseSearch?.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            filterExpenses();
        }, 300);
    });

    // Enhanced keyboard navigation
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
            switch(e.key.toLowerCase()) {
                case 'n':
                    e.preventDefault();
                    showSection('today');
                    break;
                case 'h':
                    e.preventDefault();
                    showSection('history');
                    break;
                case 'i':
                    e.preventDefault();
                    showSection('insights');
                    break;
            }
        }

        if (e.key === 'Escape') {
            closeAllModals();
        }
    });

    // iOS-specific: Enhanced touch-based escape mechanism for modal freezes
    if (isIOSDevice()) {
        let touchStartTime = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(e) {
            touchStartTime = Date.now();
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        document.addEventListener('touchend', function(e) {
            const touchDuration = Date.now() - touchStartTime;
            const touchEndY = e.changedTouches[0].clientY;
            const touchDistance = Math.abs(touchEndY - touchStartY);
            
            // If user holds touch for 3+ seconds on modal background, force close all modals
            if (touchDuration > 3000 && e.target.classList.contains('modal') && touchDistance < 10) {
                closeAllModals();
                showNotification('Modal closed - long tap detected', 'info');
            }
        }, { passive: true });
        
        // Additional iOS safety: detect if modal becomes unresponsive
        let modalCheckInterval;
        document.addEventListener('touchstart', function(e) {
            if (e.target.closest('.modal') && iosModalState.isModalOpen) {
                // Start checking for modal responsiveness
                clearInterval(modalCheckInterval);
                modalCheckInterval = setInterval(() => {
                    const modal = document.querySelector('.modal.show');
                    if (modal && !modal.style.pointerEvents) {
                        // Modal might be frozen, apply emergency fix
                        console.warn('üö® iOS Modal freeze detected, applying emergency fix');
                        modal.style.pointerEvents = 'auto';
                        modal.style.touchAction = 'manipulation';
                    }
                }, 1000);
                
                // Clear interval after 10 seconds
                setTimeout(() => clearInterval(modalCheckInterval), 10000);
            }
        }, { passive: true });
    }

    // Initialize real-time validation
    setTimeout(() => {
        setInterval(() => {
            validateSubscriptionInBackground().catch(error => console.log('Background validation:', error));
        }, 5 * 60 * 1000); // Every 5 minutes
    }, 10000); // Start after 10 seconds
}

// ======================
// --- Subscription Management ---
// ======================
async function checkSubscriptionStatusFromServer() {
    const token = localStorage.getItem('subscriptionToken');
    if (!token) {
        console.log('No subscription token found');
        return;
    }

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

        const response = await fetch(`/api/check-subscription?token=${encodeURIComponent(token)}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.success && data.active) {
            localStorage.setItem('isSubscribed', 'true');
            isSubscribed = true;
            updateTrialCountdownWithAlreadySubscribed();
        }
    } catch (error) {
        console.log('Failed to check subscription status:', error);
    }
}

async function verifySubscriptionToken(token) {
    try {
        console.log('üîç Verifying subscription token for iOS...');
        
        // Immediately set subscription status and prevent modal
        safeLocalStorageSet('isSubscribed', 'true');
        safeLocalStorageSet('hasSeenWelcome', 'true');
        isSubscribed = true;
        
        // iOS-specific: Set prevention flag
        if (isIOSDevice()) {
            iosModalState.preventModalShow = true;
            closeAllModals(); // Force close any existing modals
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);

        const response = await fetch('/api/verify-subscription', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ token: token }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
            console.log('‚úÖ Subscription verified successfully');
            
            // Update UI immediately
            updateTrialCountdownWithAlreadySubscribed();
            manageSubscriptionButtons();
            
            // Clear URL parameters to prevent re-processing
            if (window.history && window.history.replaceState) {
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            
            // Show success notification
            setTimeout(() => {
                showNotification('Welcome! Your subscription is now active.', 'success');
            }, 500);
            
        } else {
            console.warn('‚ö†Ô∏è Subscription verification failed:', data.message);
            // Reset subscription status
            safeLocalStorageSet('isSubscribed', 'false');
            isSubscribed = false;
            
            if (isIOSDevice()) {
                iosModalState.preventModalShow = false;
            }
        }
    } catch (error) {
        console.error('‚ùå Subscription verification error:', error);
        // Reset subscription status on error
        safeLocalStorageSet('isSubscribed', 'false');
        isSubscribed = false;
        
        if (isIOSDevice()) {
            iosModalState.preventModalShow = false;
        }
    }
}

// ======================
// --- Modal Functions - IMPROVED ---
// ======================

function showWelcomeModal() {
    // Comprehensive checks to prevent showing for subscribed users
    const isUserSubscribed = safeLocalStorageGet('isSubscribed') === 'true' || isSubscribed;
    const hasSeenWelcome = safeLocalStorageGet('hasSeenWelcome');
    const hasTokenInUrl = window.location.search.includes('token');
    const hasSubscriptionToken = safeLocalStorageGet('subscriptionToken');

    // Block modal for any subscription-related scenario
    if (isUserSubscribed || hasSeenWelcome || hasTokenInUrl || hasSubscriptionToken) {
        console.log('üö´ Welcome modal blocked - user is subscribed, has seen welcome, or has tokens');
        return;
    }

    // Additional iOS-specific protection - ALWAYS block on iOS if there are ANY URL params
    if (isIOSDevice()) {
        // Check prevention flag
        if (iosModalState.preventModalShow) {
            console.log('üö´ iOS Welcome modal blocked - prevention flag set');
            safeLocalStorageSet('hasSeenWelcome', 'true');
            return;
        }
        
        // Block if ANY URL parameters exist on iOS (aggressive prevention)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.toString().length > 0) {
            console.log('üö´ iOS Welcome modal blocked - any URL params detected');
            safeLocalStorageSet('hasSeenWelcome', 'true'); // Prevent future attempts
            return;
        }
        
        // Extra aggressive iOS checks
        if (window.location.href.includes('?') || 
            window.location.href.includes('#') ||
            document.referrer.includes('stripe') ||
            document.referrer.includes('payment')) {
            console.log('üö´ iOS Welcome modal blocked - payment/redirect detected');
            safeLocalStorageSet('hasSeenWelcome', 'true');
            return;
        }
        
        // Check if this is a reload/refresh on iOS
        if (performance.navigation && performance.navigation.type === 1) {
            console.log('üö´ iOS Welcome modal blocked - page refresh detected');
            safeLocalStorageSet('hasSeenWelcome', 'true');
            return;
        }
        
        // Extra check for iOS Safari's weird behavior with localStorage
        try {
            const testStorage = window.localStorage || window.sessionStorage;
            if (!testStorage) {
                console.log('üö´ Welcome modal blocked - iOS storage not available');
                return;
            }
        } catch (e) {
            console.log('üö´ Welcome modal blocked - iOS storage access error');
            return;
        }
    }

    const modal = document.getElementById('welcomeModal');
    if (modal) {
        // iOS-specific modal setup with improved handling
        if (isIOSDevice()) {
            applyIOSModalStyles(modal);
        } else {
            // Standard modal setup for non-iOS devices
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.zIndex = '10000';
        }
        
        modal.style.display = 'flex';
        modal.classList.add('active');
        
        // Force reflow before adding show class
        modal.offsetHeight;
        
        setTimeout(() => {
            modal.classList.add('show');
            // Focus on close button for accessibility
            const closeBtn = modal.querySelector('#closeWelcomeBtn');
            if (closeBtn) {
                closeBtn.focus();
                
                // iOS-specific: Ensure button is properly interactive
                if (isIOSDevice()) {
                    closeBtn.style.pointerEvents = 'auto';
                    closeBtn.style.touchAction = 'manipulation';
                }
            }
        }, 10);
        
        console.log('‚úÖ Welcome modal displayed for new user');
    } else {
        console.error('‚ùå Welcome modal element not found');
    }
}

// Make closeWelcomeModal globally accessible with improved iOS handling
window.closeWelcomeModal = function closeWelcomeModal() {
    console.log('üî• closeWelcomeModal called');

    const modal = document.getElementById('welcomeModal');
    if (modal) {
        // Set the flag immediately to prevent re-showing
        safeLocalStorageSet('hasSeenWelcome', 'true');
        console.log('‚úÖ hasSeenWelcome flag set');

        // iOS-specific: Use improved cleanup
        if (isIOSDevice()) {
            // Remove modal classes immediately
            modal.classList.remove('show', 'active');
            
            // Apply immediate hiding
            modal.style.display = 'none';
            modal.style.opacity = '0';
            modal.style.pointerEvents = 'none';
            modal.style.visibility = 'hidden';
            
            // Remove iOS-specific styles
            removeIOSModalStyles(modal);
            
            console.log('üì± iOS modal force closed with improved cleanup');
        } else {
            // Standard modal closing for non-iOS
            modal.classList.remove('show', 'active');
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300);
        }

        // Force focus to main content after modal closes
        const cleanup = () => {
            const mainContent = document.getElementById('main-content') || document.querySelector('.container');
            if (mainContent) {
                mainContent.focus();
            }
            
            // Extra cleanup for iOS
            if (isIOSDevice()) {
                // Clear any remaining modal artifacts
                document.querySelectorAll('.modal').forEach(m => {
                    if (m.style.display !== 'none') {
                        m.style.display = 'none';
                    }
                });
                
                // Force window resize event to fix any layout issues
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 50);
            }
        };

        if (isIOSDevice()) {
            cleanup();
        } else {
            setTimeout(cleanup, 350);
        }

        console.log('‚úÖ Welcome modal closed successfully');
    } else {
        console.error('‚ùå Welcome modal element not found');
    }
};

function closeAllModals() {
    document.querySelectorAll('.modal').forEach(modal => {
        modal.classList.remove('show', 'active');
        modal.style.display = 'none';

        // iOS-specific: Remove any remaining modal states with improved handling
        if (isIOSDevice()) {
            modal.style.opacity = '0';
            modal.style.visibility = 'hidden';
            modal.style.pointerEvents = 'none';
            modal.style.zIndex = '-1';
            modal.style.transform = 'scale(0)';
            
            // Apply improved iOS cleanup
            removeIOSModalStyles(modal);
        }
    });

    // iOS-specific: Additional cleanup with improved handling
    if (isIOSDevice()) {
        // Restore body styles if any modal was open
        if (iosModalState.isModalOpen) {
            restoreBodyStyles();
        }
        
        // Force reflow to ensure changes take effect
        document.body.offsetHeight;
        
        // Set the flag to prevent welcome modal
        safeLocalStorageSet('hasSeenWelcome', 'true');
        
        console.log('üì± iOS: All modals forcibly closed with improved cleanup');
    }
}

// ======================
// --- Placeholder for remaining functions ---
// ======================
// Note: The rest of the functions (addExpense, updateSummary, updateInsights, etc.) 
// remain the same as in the original script. They are not included here to keep 
// the response focused on the modal-related fixes.

// The key improvements made:
// 1. Added proper iOS modal state management
// 2. Implemented saveBodyStyles/restoreBodyStyles functions
// 3. Created applyIOSModalStyles/removeIOSModalStyles functions
// 4. Avoided using position: fixed on body for iOS
// 5. Added comprehensive touch event handling
// 6. Implemented modal freeze detection and recovery
// 7. Enhanced prevention logic for subscription scenarios
// 8. Added proper cleanup and layout recalculation

// This addresses the core iOS Safari modal freezing issues identified in the research.


// ======================
// --- Remaining Essential Functions ---
// ======================

// Already Subscribed Feature Functions
function initializeAlreadySubscribedFeature() {
    const alreadySubscribedModal = document.getElementById('alreadySubscribedModal');
    const closeAlreadySubscribedBtn = document.getElementById('closeAlreadySubscribedBtn');
    const alreadySubscribedForm = document.getElementById('alreadySubscribedForm');

    if (closeAlreadySubscribedBtn) {
        closeAlreadySubscribedBtn.addEventListener('click', () => {
            if (alreadySubscribedModal) {
                alreadySubscribedModal.classList.remove('show');
                setTimeout(() => {
                    alreadySubscribedModal.style.display = 'none';
                }, 300);
            }
        });
    }

    if (alreadySubscribedForm) {
        alreadySubscribedForm.addEventListener('submit', handleAlreadySubscribedSubmit);
    }

    if (alreadySubscribedModal) {
        alreadySubscribedModal.addEventListener('click', (e) => {
            if (e.target === alreadySubscribedModal) {
                closeAlreadySubscribedBtn.click();
            }
        });
    }

    document.addEventListener('click', (e) => {
        if (e.target.id === 'alreadySubscribedBtn' ||
            e.target.id === 'alreadySubscribedActionBtn' ||
            e.target.classList.contains('already-subscribed-btn') ||
            e.target.getAttribute('data-action') === 'already-subscribed') {
            e.preventDefault();
            e.stopPropagation();

            if (!isSubscribed) {
                const email = prompt('Enter the email address you used to purchase your subscription:');
                if (email && email.trim()) {
                    handleDirectSubscriptionVerification(email.trim());
                }
            }
        }
    });

    manageSubscriptionButtons();
}

async function handleDirectSubscriptionVerification(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        showNotification('Please enter a valid email address', 'error');
        return;
    }

    showNotification('Verifying subscription...', 'info');

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        const response = await fetch('/api/verify-and-activate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ email }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        let data;
        try {
            data = await response.json();
        } catch (parseError) {
            throw new Error('Invalid response from server');
        }

        if (response.ok && data.success) {
            safeLocalStorageSet('subscriptionToken', data.token);
            safeLocalStorageSet('isSubscribed', 'true');
            isSubscribed = true;

            showNotification('üéâ Pro subscription activated successfully!', 'success');
            updateTrialCountdownWithAlreadySubscribed();

            if (isIOSDevice()) {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ type: 'FORCE_IOS_CACHE_CLEAR' });
                }

                if ('caches' in window) {
                    caches.keys().then(cacheNames => {
                        cacheNames.forEach(cacheName => caches.delete(cacheName));
                    });
                }

                setTimeout(() => {
                    window.location.href = window.location.protocol + '//' + window.location.host + window.location.pathname + '?ios_refresh=' + Date.now() + '&t=' + Math.random();
                }, 1000);
            } else {
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
            }

        } else {
            const errorMessage = data?.message || 'Failed to verify subscription';
            showNotification(errorMessage, 'error');
        }

    } catch (error) {
        let errorMessage = 'Failed to verify subscription. Please try again.';

        if (error.name === 'AbortError') {
            errorMessage = 'Request timed out. Please check your connection and try again.';
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
            errorMessage = 'Network error: Unable to connect to server. Check your connection.';
        } else if (error.name === 'SyntaxError') {
            errorMessage = 'Server response error: Invalid data received.';
        } else if (error.message) {
            errorMessage = `Error: ${error.message}`;
        }

        showNotification(errorMessage, 'error');
    }
}

async function handleAlreadySubscribedSubmit(e) {
    e.preventDefault();

    const emailInput = document.getElementById('subscriberEmail');
    const email = emailInput ? emailInput.value.trim() : '';

    if (!email) {
        showNotification('Please enter your email address', 'error');
        if (emailInput) emailInput.focus();
        return;
    }

    const modal = document.getElementById('alreadySubscribedModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }

    await handleDirectSubscriptionVerification(email);
}

// Enhanced Validation System
function initializeEnhancedValidation() {
    setInterval(async () => {
        try {
            await validateSubscriptionInBackground();
        } catch (error) {
            console.log('Periodic validation error:', error);
        }
    }, 15 * 60 * 1000);

    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && isSubscribed) {
            setTimeout(() => {
                validateSubscriptionInBackground().catch(error =>
                    console.log('Focus validation error:', error)
                );
            }, 2000);
        }
    });
}

async function validateSubscriptionInBackground() {
    const token = safeLocalStorageGet('subscriptionToken');
    if (!token || !isSubscribed) return;

    try {
        const response = await fetch(`/api/check-subscription?token=${encodeURIComponent(token)}`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });

        if (response.ok) {
            const data = await response.json();
            if (!data.success || !data.active) {
                safeLocalStorageSet('isSubscribed', 'false');
                isSubscribed = false;
                updateTrialCountdownWithAlreadySubscribed();
            }
        }
    } catch (error) {
        console.log('Background validation failed:', error);
    }
}

// Trial Management
function updateTrialCountdownWithAlreadySubscribed() {
    const subscriptionStatus = safeLocalStorageGet('isSubscribed') === 'true';
    isSubscribed = subscriptionStatus;

    const trialSection = document.getElementById('trialSection');
    const trialCountdown = document.getElementById('trialCountdown');
    const upgradeButtons = document.querySelectorAll('.upgrade-btn, .subscribe-btn');

    if (subscriptionStatus) {
        if (trialSection) trialSection.style.display = 'none';
        if (trialCountdown) {
            trialCountdown.style.background = 'linear-gradient(135deg, #047857, #059669)';
            trialCountdown.innerHTML = '<span style="color: white; font-weight: bold;">‚úÖ Pro Subscription Active</span>';
        }

        upgradeButtons.forEach(btn => {
            btn.style.display = 'none';
        });

        console.log('‚úÖ Trial section and subscribe buttons hidden - user is subscribed');
        return;
    }

    if (trialSection) trialSection.style.display = 'block';
    upgradeButtons.forEach(btn => btn.style.display = 'inline-block');

    const trialStart = parseInt(trialStartDate);
    const trialDuration = 3 * 24 * 60 * 60 * 1000;
    const trialEnd = trialStart + trialDuration;
    const now = Date.now();
    const timeLeft = trialEnd - now;

    if (timeLeft <= 0) {
        isTrialExpired = true;
        const trialInfo = document.getElementById('trialInfo');
        if (trialInfo) {
            trialInfo.innerHTML = `
                <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #ef4444, #dc2626); border-radius: 12px; color: white;">
                    <h3 style="margin: 0 0 10px 0;">‚è∞ Trial Expired</h3>
                    <p style="margin: 0 0 15px 0;">Your 3-day trial has ended. Upgrade to continue using all features!</p>
                    <button onclick="window.open('https://buy.stripe.com/5kAdRF0Qq3Fo9lS4gg', '_blank')" class="upgrade-btn" style="background: white; color: #ef4444; border: none; padding: 10px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">Upgrade to Pro</button>
                </div>
            `;
        }
        return;
    }

    const days = Math.floor(timeLeft / (24 * 60 * 60 * 1000));
    const hours = Math.floor((timeLeft % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
    const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));

    const trialInfo = document.getElementById('trialInfo');
    if (trialInfo) {
        const existingContent = trialInfo.querySelector('[data-trial-content]');
        if (existingContent) {
            const timeElement = existingContent.querySelector('[data-time-remaining]');
            if (timeElement) {
                timeElement.textContent = `${days}d ${hours}h ${minutes}m remaining`;
                return;
            }
        }

        trialInfo.innerHTML = `
            <div data-trial-content style="text-align: center; padding: 15px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 12px; color: white;">
                <h3 style="margin: 0 0 10px 0;">‚è∞ Free Trial</h3>
                <p data-time-remaining style="margin: 0 0 10px 0; font-size: 18px; font-weight: bold;">${days}d ${hours}h ${minutes}m remaining</p>
                <p style="margin: 0 0 15px 0; font-size: 14px;">Enjoying the app? Upgrade to Pro for unlimited access!</p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="window.open('https://buy.stripe.com/5kAdRF0Qq3Fo9lS4gg', '_blank')" class="upgrade-btn" style="background: white; color: #f59e0b; border: none; padding: 8px 16px; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 14px;">Upgrade to Pro</button>
                </div>
            </div>
        `;
    }

    if (!isSubscribed) {
        manageSubscriptionButtons();
    }
}

function manageSubscriptionButtons() {
    // This function manages the visibility of subscription-related buttons
    // Implementation depends on your specific UI structure
}

// Expense Management Functions
function populateExpenseGrid() {
    const grid = document.getElementById('expenseGrid');
    if (!grid) return;

    const fragment = document.createDocumentFragment();

    expenseCategories.forEach(category => {
        const card = document.createElement('div');
        card.className = 'expense-card';
        card.dataset.category = category.id;
        card.onclick = (e) => {
            if (e.target.closest('.expense-form')) return;
            toggleExpenseCard(category.id);
        };
        card.innerHTML = `
            <div class="expense-header">
                <div class="expense-icon">${category.icon}</div>
                <div class="expense-title">${category.name}</div>
            </div>
            <div class="expense-form" id="form-${category.id}">
                <div class="form-group">
                    <input type="number" id="amount-${category.id}" placeholder="Amount ($)" step="0.01" min="0" required>
                </div>
                <div class="form-group">
                    <input type="text" id="description-${category.id}" placeholder="Description (optional)">
                </div>
                <div class="form-group">
                    <input type="text" id="location-${category.id}" placeholder="Location (City, State)">
                </div>
                <div class="form-group">
                    <input type="file" id="receipt-${category.id}" accept="image/*" class="receipt-input">
                </div>
                <div class="form-buttons">
                    <button type="button" onclick="addExpense('${category.id}')" class="btn-primary">Add Expense</button>
                    <button type="button" onclick="toggleExpenseCard('${category.id}')" class="btn-secondary">Cancel</button>
                </div>
            </div>
        `;
        fragment.appendChild(card);
    });

    grid.appendChild(fragment);
}

function toggleExpenseCard(categoryId) {
    const card = document.querySelector(`[data-category="${categoryId}"]`);
    const form = document.getElementById(`form-${categoryId}`);

    if (!card || !form) return;

    const isExpanded = card.classList.contains('expanded');

    document.querySelectorAll('.expense-card').forEach(c => {
        c.classList.remove('expanded');
    });

    if (!isExpanded) {
        card.classList.add('expanded');
        setTimeout(() => {
            const amountInput = document.getElementById(`amount-${categoryId}`);
            if (amountInput) amountInput.focus();
        }, 150);
    }
}

function addExpense(categoryId) {
    const amountInput = document.getElementById(`amount-${categoryId}`);
    const descriptionInput = document.getElementById(`description-${categoryId}`);
    const locationInput = document.getElementById(`location-${categoryId}`);
    const receiptInput = document.getElementById(`receipt-${categoryId}`);

    const addButton = document.querySelector(`[data-category="${categoryId}"] .btn-primary`);
    const originalText = addButton.textContent;
    addButton.textContent = 'Adding...';
    addButton.disabled = true;

    const amount = parseFloat(amountInput.value);
    const description = descriptionInput.value.trim();
    const location = locationInput.value.trim();

    if (!amount || amount <= 0 || amount > 99999.99) {
        showNotification('Please enter a valid amount between $0.01 and $99,999.99', 'error');
        amountInput.focus();
        addButton.textContent = originalText;
        addButton.disabled = false;
        return;
    }

    if (description.length > 200) {
        showNotification('Description must be 200 characters or less', 'error');
        descriptionInput.focus();
        addButton.textContent = originalText;
        addButton.disabled = false;
        return;
    }

    if (location.length > 100) {
        showNotification('Location must be 100 characters or less', 'error');
        locationInput.focus();
        addButton.textContent = originalText;
        addButton.disabled = false;
        return;
    }

    const category = expenseCategories.find(cat => cat.id === categoryId);
    const expense = {
        id: Date.now() + Math.random(),
        categoryId: categoryId,
        categoryName: category.name,
        categoryIcon: category.icon,
        amount: amount,
        description: description || '',
        location: location || '',
        date: new Date().toLocaleDateString('en-CA'),
        timestamp: Date.now()
    };

    if (receiptInput.files && receiptInput.files[0]) {
        const file = receiptInput.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            expense.receipt = e.target.result;
            saveExpense(expense);
        };
        reader.readAsDataURL(file);
    } else {
        saveExpense(expense);
    }

    function saveExpense(expenseData) {
        expenses.push(expenseData);
        localStorage.setItem('truckerExpenses', JSON.stringify(expenses));

        amountInput.value = '';
        descriptionInput.value = '';
        locationInput.value = '';
        receiptInput.value = '';

        const card = document.querySelector(`[data-category="${categoryId}"]`);
        if (card) card.classList.remove('expanded');

        updateSummary();
        updateInsights();
        updateHistory();

        addButton.textContent = originalText;
        addButton.disabled = false;

        showNotification(`${category.name} expense added successfully!`, 'success');
    }
}

function updateSummary() {
    const today = new Date().toISOString().split('T')[0];
    const todayExpenses = expenses.filter(ex => ex.date === today);
    const totalExpenses = expenses.reduce((sum, ex) => sum + ex.amount, 0);
    const todayTotal = todayExpenses.reduce((sum, ex) => sum + ex.amount, 0);
    const dailyEl = document.getElementById('dailyTotal');
    const totalEl = document.getElementById('totalExpenses');
    if (dailyEl) dailyEl.textContent = `$${todayTotal.toFixed(2)}`;
    if (totalEl) totalEl.textContent = `$${totalExpenses.toFixed(2)}`;
}

function updateInsights() {
    const totalExpenses = expenses.reduce((sum, ex) => sum + ex.amount, 0);
    const uniqueDays = [...new Set(expenses.map(ex => new Date(ex.date).toDateString()))].length;
    const averageDaily = uniqueDays > 0 ? totalExpenses / uniqueDays : 0;

    const categoryTotals = {};
    expenses.forEach(ex => {
        categoryTotals[ex.categoryName] = (categoryTotals[ex.categoryName] || 0) + ex.amount;
    });

    const topCategory = Object.keys(categoryTotals).reduce((a, b) => categoryTotals[a] > categoryTotals[b] ? a : b, 'None');

    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonth = lastMonthDate.getMonth();
    const lastMonthYear = lastMonthDate.getFullYear();

    const currentMonthExpenses = expenses.filter(ex => {
        const d = new Date(ex.date);
        return d.getMonth() === currentMonth && d.getFullYear() === currentYear;
    }).reduce((sum, ex) => sum + ex.amount, 0);

    const lastMonthExpenses = expenses.filter(ex => {
        const d = new Date(ex.date);
        return d.getMonth() === lastMonth && d.getFullYear() === lastMonthYear;
    }).reduce((sum, ex) => sum + ex.amount, 0);

    const monthlyChange = lastMonthExpenses > 0 ? ((currentMonthExpenses - lastMonthExpenses) / lastMonthExpenses * 100).toFixed(1) : (currentMonthExpenses > 0 ? '‚àû' : '0');

    const elements = {
        'insightsTotalExpenses': `$${totalExpenses.toFixed(2)}`,
        'averageDailyExpense': `$${averageDaily.toFixed(2)}`,
        'topCategory': topCategory,
        'currentMonthTotal': `$${currentMonthExpenses.toFixed(2)}`,
        'lastMonthTotal': `$${lastMonthExpenses.toFixed(2)}`
    };

    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });

    const changeElement = document.getElementById('monthlyChange');
    if (changeElement) {
        if (monthlyChange === '‚àû') {
            changeElement.textContent = 'New spending';
            changeElement.style.color = '#fbbf24';
        } else if (monthlyChange === '0') {
            changeElement.textContent = 'No change';
            changeElement.style.color = '#6b7280';
        } else {
            const changeValue = parseFloat(monthlyChange);
            changeElement.textContent = `${changeValue > 0 ? '+' : ''}${changeValue}%`;
            changeElement.style.color = changeValue > 0 ? '#ef4444' : '#10b981';
        }
    }

    updateCategoryBreakdown(categoryTotals);
    updateMonthlyBreakdown();
}

function updateCategoryBreakdown(categoryTotals) {
    const categoryList = document.getElementById('categoryList');
    if (!categoryList) return;

    if (Object.keys(categoryTotals).length === 0) {
        categoryList.innerHTML = '<p class="no-data-message">No expense data available for analysis.</p>';
        return;
    }

    const sortedCategories = Object.entries(categoryTotals)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 10);

    const totalAmount = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);

    const content = sortedCategories.map(([categoryName, amount]) => {
        const percentage = totalAmount > 0 ? ((amount / totalAmount) * 100).toFixed(1) : '0';
        const categoryData = expenseCategories.find(cat => cat.name === categoryName);
        const icon = categoryData ? categoryData.icon : 'üíº';

        return `
            <li class="category-breakdown-item">
                <div class="summary-item" style="padding: 15px 0; border-bottom: 1px solid var(--border-light); align-items: center;">
                    <span style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">${icon}</span>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 2px;">${categoryName}</div>
                            <div style="font-size: 0.85rem; opacity: 0.7;">${percentage}% of total</div>
                        </div>
                    </span>
                    <span style="font-weight: 700; color: var(--secondary-color);">$${amount.toFixed(2)}</span>
                </div>
            </li>`;
    }).join('');

    categoryList.innerHTML = content;
}

function updateMonthlyBreakdown() {
    const monthlyBreakdown = document.getElementById('monthlyBreakdown');
    if (!monthlyBreakdown) return;

    if (expenses.length === 0) {
        monthlyBreakdown.innerHTML = '<p class="no-data-message">No expense data available for monthly analysis.</p>';
        return;
    }

    const monthlyTotals = {};
    expenses.forEach(ex => {
        const date = new Date(ex.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        const monthName = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

        if (!monthlyTotals[monthKey]) {
            monthlyTotals[monthKey] = { name: monthName, total: 0, count: 0 };
        }
        monthlyTotals[monthKey].total += ex.amount;
        monthlyTotals[monthKey].count += 1;
    });

    const sortedMonths = Object.entries(monthlyTotals)
        .sort(([a], [b]) => b.localeCompare(a))
        .slice(0, 6);

    const content = sortedMonths.map(([monthKey, data]) => {
        const average = data.count > 0 ? data.total / data.count : 0;

        return `
            <li class="monthly-breakdown-item">
                <div class="summary-item" style="padding: 15px 0; border-bottom: 1px solid var(--border-light); align-items: center;">
                    <span style="display: flex; flex-direction: column;">
                        <div style="font-weight: 600; margin-bottom: 2px;">${data.name}</div>
                        <div style="font-size: 0.85rem; opacity: 0.7; line-height: 1.3;">${data.count} transactions ‚Ä¢ $${average.toFixed(2)} avg</div>
                    </span>
                    <span style="font-weight: 700; color: var(--secondary-color);">$${data.total.toFixed(2)}</span>
                </div>
            </li>`;
    }).join('');

    monthlyBreakdown.innerHTML = content;
}

function updateHistory() {
    const historyList = document.getElementById('historyList');
    const filter = document.getElementById('dateFilter')?.value || 'all';

    if (!historyList) return;

    let filteredExpenses = [...expenses];
    const now = new Date();

    switch (filter) {
        case 'today':
            filteredExpenses = expenses.filter(ex => new Date(ex.date).toDateString() === now.toDateString());
            break;
        case 'week':
            const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            filteredExpenses = expenses.filter(ex => new Date(ex.date) >= weekAgo);
            break;
        case 'month':
            filteredExpenses = expenses.filter(ex => {
                const expenseDate = new Date(ex.date);
                return expenseDate.getMonth() === now.getMonth() && expenseDate.getFullYear() === now.getFullYear();
            });
            break;
        case 'year':
            filteredExpenses = expenses.filter(ex => new Date(ex.date).getFullYear() === now.getFullYear());
            break;
    }

    if (filteredExpenses.length === 0) {
        historyList.innerHTML = '<p style="text-align: center; color: var(--text-light); opacity: 0.7; margin: 40px 0;">No expenses found for the selected period.</p>';
        return;
    }

    filteredExpenses.sort((a, b) => new Date(b.date) - new Date(a.date));

    historyList.innerHTML = filteredExpenses.map(ex => `
        <li class="history-item">
            <div class="expense-card" style="cursor: default; margin-bottom: 15px;">
                <div class="expense-header">
                    <div class="expense-icon">${ex.categoryIcon}</div>
                    <div class="expense-title">${ex.categoryName}</div>
                    <div class="expense-amount">$${ex.amount.toFixed(2)}</div>
                </div>
                <div class="expense-subtitle">${new Date(ex.date).toLocaleDateString()}</div>
                ${ex.description ? `<div class="expense-description"><strong>Description:</strong> ${ex.description}</div>` : ''}
                ${ex.location ? `<div class="expense-description"><strong>Location:</strong> ${ex.location}</div>` : ''}
                ${ex.receipt ? `<div class="receipt-preview" style="margin-top: 15px; text-align: center;"><img src="${ex.receipt}" class="receipt-image" alt="Receipt" style="max-width: 200px; max-height: 150px; border-radius: 6px; border: 1px solid var(--border-light);"></div>` : ''}
                <button onclick="deleteExpense('${ex.id}')" class="btn-delete" style="margin-top: 15px;">Delete</button>
            </div>
        </li>
    `).join('');
}

function deleteExpense(expenseId) {
    if (confirm('Are you sure you want to delete this expense?')) {
        expenses = expenses.filter(ex => ex.id != expenseId);
        localStorage.setItem('truckerExpenses', JSON.stringify(expenses));
        updateSummary();
        updateInsights();
        updateHistory();
        showNotification('Expense deleted successfully!', 'success');
    }
}

function filterExpenses() {
    updateHistory();
}

// Navigation & UI Functions
function showSection(sectionName) {
    document.querySelectorAll('.section').forEach(section => section.classList.add('hidden'));
    document.getElementById(`${sectionName}Section`).classList.remove('hidden');
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`[data-section="${sectionName}"]`)?.classList.add('active');
    currentSection = sectionName;

    if (sectionName === 'history') {
        updateHistory();
    } else if (sectionName === 'insights') {
        updateInsights();
    }
}

function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('darkMode', isDarkMode);
    updateToggleIcon();
}

function updateToggleIcon() {
    const toggle = document.querySelector('.dark-mode-toggle');
    if (toggle) {
        toggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
    }
}

// Utility Functions
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;

    const colors = {
        success: '#10b981',
        error: '#ef4444',
        warning: '#f59e0b',
        info: '#3b82f6'
    };

    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${colors[type] || colors.info};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-weight: 500;
        max-width: 300px;
        word-wrap: break-word;
        animation: slideIn 0.3s ease;
    `;

    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 4000);
}

// Service Worker Cache Management
function clearServiceWorkerCache() {
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_CACHE' });
    }
}

// Export Functions (if needed)
function exportToPDF() {
    const printStyles = document.createElement('style');
    printStyles.innerHTML = `
        @media print {
            .expense-form { display: none !important; }
            .expense-card.expanded { background: white !important; color: black !important; }
            .expense-card.expanded .expense-form { display: none !important; }
            .action-buttons { display: none !important; }
            .navigation { display: none !important; }
            .header-controls { display: none !important; }
            .privacy-notice { display: none !important; }
            body { background: white !important; }
            .section { box-shadow: none !important; border: 1px solid #ccc !important; }
        }
    `;
    document.head.appendChild(printStyles);

    document.querySelectorAll('.expense-card.expanded').forEach(card => {
        card.classList.remove('expanded');
    });

    setTimeout(() => {
        window.print();
        setTimeout(() => {
            document.head.removeChild(printStyles);
        }, 1000);
    }, 100);
}

function exportHistoryToPDF() {
    showSection('history');
    setTimeout(() => {
        const printStyles = document.createElement('style');
        printStyles.innerHTML = `
            @media print {
                .action-buttons { display: none !important; }
                .navigation { display: none !important; }
                .header-controls { display: none !important; }
                .privacy-notice { display: none !important; }
                body { background: white !important; }
                .section { box-shadow: none !important; border: 1px solid #ccc !important; }
                .btn-delete { display: none !important; }
            }
        `;
        document.head.appendChild(printStyles);

        setTimeout(() => {
            window.print();
            setTimeout(() => {
                document.head.removeChild(printStyles);
            }, 1000);
        }, 100);
    }, 200);
}

function exportInsightsToPDF() {
    showSection('insights');
    setTimeout(() => {
        const printStyles = document.createElement('style');
        printStyles.innerHTML = `
            @media print {
                .action-buttons { display: none !important; }
                .navigation { display: none !important; }
                .header-controls { display: none !important; }
                .privacy-notice { display: none !important; }
                body { background: white !important; }
                .section { box-shadow: none !important; border: 1px solid #ccc !important; }
            }
        `;
        document.head.appendChild(printStyles);

        setTimeout(() => {
            window.print();
            setTimeout(() => {
                document.head.removeChild(printStyles);
            }, 1000);
        }, 100);
    }, 200);
}

// Initialize everything when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

